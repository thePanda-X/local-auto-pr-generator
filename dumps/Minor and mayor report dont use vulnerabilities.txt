{"src/graylog/graylog.module.ts":"@@ -7,6 +7,7 @@ import { GraylogLogsController } from './controllers/logs.controller';\n import { GraylogLogsService } from './services/logs.service';\n import { InfrastructureModule } from 'src/infrastructure/infrastructure.module';\n import { Infrastructure } from 'src/infrastructure/entities/infrastructure.entity';\n+import { WazuAgent } from 'src/wazuh/entities/agent.entity';\n \n /**\n  * ### GraylogModule\n@@ -20,7 +21,7 @@ import { Infrastructure } from 'src/infrastructure/entities/infrastructure.entit\n  */\n @Module({\n     imports: [\n-        TypeOrmModule.forFeature([Infrastructure]),\n+        TypeOrmModule.forFeature([Infrastructure, WazuAgent]),\n         forwardRef(() => AuthModule),\n         forwardRef(() => CompanyModule),\n         forwardRef(() => InfrastructureModule),","src/graylog/services/logs.service.ts":"@@ -42,6 +42,8 @@ export class GraylogLogsService extends ApiRequest {\n         private readonly multiInfraService: MultiInfrastructureService,\n         @InjectRepository(Infrastructure)\n         private readonly infrastructureRepository: Repository<Infrastructure>,\n+        @InjectRepository(WazuAgent)\n+        private readonly agentRepository: Repository<WazuAgent>,\n     ) {\n         super();\n         this.headers['X-Requested-By'] = ''; // Enviar el header para los POST\n@@ -817,4 +819,60 @@ export class GraylogLogsService extends ApiRequest {\n             });\n         }\n     }\n+\n+    // Mock data, remplazar por metodo real que devuelva los graslogs de un agente de un agente.\n+    public async fetchLogsFromAgentForReports(agentId: number, numberOfFiles = 20): Promise<{ agent_name: string, agentId: number, name: string, date: string, description: string }[]> {\n+\n+        const agent = await this.agentRepository.findOne({ where: { id: agentId } })\n+\n+        const randomLogOptions = [\n+            \"[2025-04-11 13:45:02] [INFO] SecurityScanner initialized. Version: 3.7.1\",\n+            \"[2025-04-11 13:45:05] [INFO] Device scan started: 192.168.1.12 (Workstation-Alpha)\",\n+            \"[2025-04-11 13:45:06] [INFO] Device scan started: 192.168.1.45 (Server-Gamma)\",\n+            \"[2025-04-11 13:45:07] [WARNING] Outdated firmware detected on 192.168.1.12. Current version: 1.2.3, Required: >=1.4.0\",\n+            \"[2025-04-11 13:45:09] [INFO] Device scan completed: 192.168.1.12 — 3 issues found\",\n+            \"[2025-04-11 13:45:12] [CRITICAL] Suspicious process detected on 192.168.1.45: /usr/bin/pscan (PID 1023)\",\n+            \"[2025-04-11 13:45:12] [ACTION] Process /usr/bin/pscan terminated on 192.168.1.45\",\n+            \"[2025-04-11 13:45:13] [INFO] Device scan completed: 192.168.1.45 — 1 critical issue found\",\n+            \"[2025-04-11 13:45:15] [INFO] Device scan started: 192.168.1.30 (Printer-Echo)\",\n+            \"[2025-04-11 13:45:16] [INFO] Device scan completed: 192.168.1.30 — No issues found\",\n+            \"[2025-04-11 13:45:20] [ALERT] Unusual network traffic detected from 192.168.1.12. Potential data exfiltration.\",\n+            \"[2025-04-11 13:45:21] [ACTION] Quarantining device: 192.168.1.12\",\n+            \"[2025-04-11 13:45:22] [INFO] Admin notified: Quarantine event on Workstation-Alpha\",\n+            \"[2025-04-11 13:45:25] [INFO] Scheduled full network scan at 02:00 AM UTC\",\n+        ];\n+\n+        const getRandomDateWithinAYear = () => {\n+            const now = new Date();\n+            const offset = Math.floor(Math.random() * 60 * 2) - 60;\n+            const randomDate = new Date(now);\n+            randomDate.setDate(now.getDate() + offset);\n+            return randomDate;\n+        };\n+\n+        const getRandomLogs = () => {\n+            const count = Math.floor(Math.random() * randomLogOptions.length) + 1;\n+            const shuffled = [...randomLogOptions].sort(() => 0.5 - Math.random());\n+            return shuffled.slice(0, count).join('\\n');\n+        };\n+\n+        const getRandomLogName = (date) => {\n+            return `logfile-${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}.log`;\n+        };\n+\n+        const logs = [];\n+\n+        for (let i = 0; i < numberOfFiles; i++) {\n+            const date = getRandomDateWithinAYear();\n+            logs.push({\n+                agent_name: agent.public_agent_name,\n+                agentId: agent.agent_id,\n+                name: getRandomLogName(date),\n+                date,\n+                description: getRandomLogs(),\n+            });\n+        }\n+\n+        return logs;\n+    }\n }","src/report/report.controller.ts":"@@ -147,4 +147,84 @@ export class ReportController {\n     ) {\n         return this.reportService.deleteReportById(user, id);\n     }\n+\n+    @Get('minor-report')\n+    @InfrastructureAccess()\n+    @ApiOperation({\n+        summary: 'Devuelve los datos para el reporte leve',\n+    })\n+    @ApiQuery({\n+        name: 'initialDate',\n+        description: 'Fecha inicial del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiQuery({\n+        name: 'finalDate',\n+        description: 'Fecha final del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiResponse({\n+        status: 200,\n+        description: 'Datos para el reporte leve',\n+        type: Object,\n+    })\n+    @ApiQuery({\n+        name: 'infraIds',\n+        description: 'ID(s) de infraestructura a consultar',\n+        type: [Number],\n+        required: true,\n+        example: 1,\n+        isArray: true,\n+    })\n+    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n+    async getMinorReportData(\n+        @ActiveUser() user: UserActiveInterface,\n+        @UserInfrastructures() infraIds: number[],\n+        @Query('initialDate') initialDate: Date,\n+        @Query('finalDate') finalDate: Date\n+    ) {\n+        return await this.reportService.getDataForMinorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n+    }\n+\n+    @Get('mayor-report')\n+    @InfrastructureAccess()\n+    @ApiOperation({\n+        summary: 'Devuelve los datos para el reporte grave',\n+    })\n+    @ApiQuery({\n+        name: 'initialDate',\n+        description: 'Fecha inicial del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiQuery({\n+        name: 'finalDate',\n+        description: 'Fecha final del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiResponse({\n+        status: 200,\n+        description: 'Datos para el reporte leve',\n+        type: Object,\n+    })\n+    @ApiQuery({\n+        name: 'infraIds',\n+        description: 'ID(s) de infraestructura a consultar',\n+        type: [Number],\n+        required: true,\n+        example: 1,\n+        isArray: true,\n+    })\n+    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n+    async getMayorReportData(\n+        @ActiveUser() user: UserActiveInterface,\n+        @UserInfrastructures() infraIds: number[],\n+        @Query('initialDate') initialDate: Date,\n+        @Query('finalDate') finalDate: Date\n+    ) {\n+        return await this.reportService.getDataForMayorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n+    }\n }","src/report/report.module.ts":"@@ -7,9 +7,19 @@ import { CompanyModule } from 'src/company/company.module';\n import { InfrastructureModule } from 'src/infrastructure/infrastructure.module';\n import { I18nModule } from 'nestjs-i18n/dist/i18n.module';\n import { WazuhModule } from 'src/wazuh/wazuh.module';\n+import { AlertModule } from 'src/alerts/alert.module';\n+import { GraylogModule } from 'src/graylog/graylog.module';\n \n @Module({\n-    imports: [AuthModule,  forwardRef(() => FileModule), forwardRef(() => CompanyModule), InfrastructureModule, forwardRef(() => WazuhModule)],\n+    imports: [\n+        AuthModule,\n+        forwardRef(() => FileModule),\n+        forwardRef(() => CompanyModule),\n+        InfrastructureModule,\n+        forwardRef(() => WazuhModule),\n+        AlertModule,\n+        GraylogModule,\n+    ],\n     controllers: [ReportController],\n     providers: [ReportService],\n     exports: [ReportService]","src/report/report.service.ts":"@@ -20,6 +20,11 @@ import { InfrastructureService } from 'src/infrastructure/infrastructure.service\n import { WazuAgent } from 'src/wazuh/entities/agent.entity';\n import { IndexerService } from 'src/wazuh/services/indexer.service';\n import { VulnerabilityInfoDTO } from 'src/wazuh/dto-outputs/vulnera-info.output.dto';\n+import { AlertService } from 'src/alerts/services/alert.service';\n+import { Alert } from 'src/alerts/entities/alert.entity';\n+import { Repository } from 'typeorm';\n+import { InjectRepository } from '@nestjs/typeorm';\n+import { GraylogLogsService } from 'src/graylog/services/logs.service';\n \n @Injectable()\n export class ReportService {\n@@ -32,6 +37,10 @@ export class ReportService {\n         private readonly companyService: CompanyService,\n         private readonly i18n: I18nService,\n         private readonly indexerService: IndexerService,\n+        @InjectRepository(Alert)\n+        private readonly alertRepo: Repository<Alert>,\n+        private readonly logService: GraylogLogsService,\n+        \n     ) {}\n \n     /**\n@@ -229,35 +238,37 @@ export class ReportService {\n                 continue;\n             }\n             const agents = await this.infrastructureService.getAllAgentsByInfrastructure(infrastructureId);\n-            const cvePromises = agents.map(agent => this.indexerService.getVulnerabilities(user, agent.id));\n-            const cves = await Promise.all(cvePromises);\n-            const cveArray: VulnerabilityInfoDTO[] = [].concat(...cves);\n+            const logPromises = agents.map(agent => this.logService.fetchLogsFromAgentForReports(agent.id));\n+            const logs = await Promise.all(logPromises);\n+            const logsArray = [].concat(...logs);\n     \n-            const cveFormatted = cveArray.map(cve => ({\n-                agent_name: cve.agent_name,\n-                agent_id: cve.agent_build_original,\n-                vulnerability_detected_at: cve.vulnerability_detected_at,\n-                vulnerability_description: cve.vulnerability_description,\n-                vulnerability_name: cve.vulnerability_category\n+            const logsFormatted = logsArray.map((log) => ({\n+                agent_name: log.agent_name,\n+                agent_id: log.agentId,\n+                log_date: log.date,\n+                log_description: log.description,\n+                log_name: log.name\n             }));\n+\n+            console.log(logsFormatted)\n     \n-            const filteredCVEs = cveFormatted.filter(cve => {\n-                const cveDate = new Date(cve.vulnerability_detected_at);\n+            const filteredLogs = logsFormatted.filter(log => {\n+                const cveDate = new Date(log.log_date);\n                 return cveDate >= initialDate && cveDate <= finalDate;\n             });\n     \n-            const groupedCVEsByAgent = filteredCVEs.reduce((acc, cve) => {\n+            const groupedLogsByAgent = filteredLogs.reduce((acc, cve) => {\n                 const agent = agents.find(agent => agent.public_agent_name === cve.agent_name);\n                 if (!acc[agent.public_agent_name]) {\n                     acc[agent.public_agent_name] = { public_agent_name: agent.public_agent_name, agent_id: agent.id, eventCount: 0, events: [] };\n                 }\n                 acc[agent.public_agent_name].eventCount++;\n-                acc[agent.public_agent_name].events.push({ desciption: cve.vulnerability_description, name: cve.vulnerability_name, date: cve.vulnerability_detected_at });\n+                acc[agent.public_agent_name].events.push({ desciption: cve.log_description, name: cve.log_name, date: cve.log_date });\n                 return acc;\n             }, {});\n     \n-            const groupedCVEsByWeek = filteredCVEs.reduce((acc, cve) => {\n-                const cveDate = new Date(cve.vulnerability_detected_at);\n+            const groupedCVEsByWeek = filteredLogs.reduce((acc, cve) => {\n+                const cveDate = new Date(cve.log_date);\n                 const day = cveDate.getDay();\n                 const diff = cveDate.getDate() - day + (day === 0 ? -6 : 1);\n                 const weekStart = new Date(cveDate.setDate(diff));\n@@ -269,8 +280,8 @@ export class ReportService {\n                 return acc;\n             }, {});\n     \n-            const groupedCVEsByMonth = filteredCVEs.reduce((acc, cve) => {\n-                const cveDate = new Date(cve.vulnerability_detected_at);\n+            const groupedCVEsByMonth = filteredLogs.reduce((acc, cve) => {\n+                const cveDate = new Date(cve.log_date);\n                 const year = cveDate.getFullYear();\n                 const month = cveDate.getMonth() + 1;\n                 const key = `${year}-${String(month).padStart(2, '0')}`;\n@@ -282,7 +293,7 @@ export class ReportService {\n             }, {});\n     \n             infrastructureReports[infrastructure.name] = {\n-                agentsInfo: groupedCVEsByAgent,\n+                agentsInfo: groupedLogsByAgent,\n                 eventsByWeek: groupedCVEsByWeek,\n                 eventsByMonth: groupedCVEsByMonth,\n             };\n@@ -298,6 +309,8 @@ export class ReportService {\n         return output;\n     }\n \n+    \n+\n \n     async getDataForMayorReport(\n         user: UserActiveInterface,\n@@ -314,39 +327,39 @@ export class ReportService {\n         const allInfraAgentsArrays = await Promise.all(promises);\n         allInfraAgentsArrays.forEach(infraAgents => agents.push(...infraAgents));\n \n-        const cvePromises = agents.map(agent => this.indexerService.getVulnerabilities(user, agent.id));\n-        const cves = await Promise.all(cvePromises);\n-        const cveArray: VulnerabilityInfoDTO[] = [].concat(...cves);\n+        const alertPromises = agents.map(agent => this.alertRepo.find({ where: { agent: { id: agent.id } }, relations: ['agent'] }));\n+        const alerts = await Promise.all(alertPromises);\n+        const alertsArray: Partial<Alert>[] = [].concat(...alerts);\n \n-        const cveFormatted = cveArray.map(cve => {\n+        const alertsFormatted = alertsArray.map((alert) => {\n             return {\n-                agent_name: cve.agent_name,\n-                vulnerability_id: cve.vulnerability_id,\n-                vulnerability_detected_at: cve.vulnerability_detected_at,\n-                vulnerability_description: cve.vulnerability_description,\n-                vulnerability_name: cve.vulnerability_category,\n-                vulnerability_severity: cve.vulnerability_severity,\n+                agent_id: alert.agent.id,\n+                alert_id: alert.ruleId,\n+                alert_detected_at: alert.timestamp,\n+                alert_description: alert.ruleDescription,\n+                alert_severity: alert.severity,\n+                alert_ruleLevel: alert.ruleLevel,\n             }\n         })\n \n-        const filteredCVEs = cveFormatted.filter(cve => {\n-            const cveDate = new Date(cve.vulnerability_detected_at);\n+        const filteredAlerts = alertsFormatted.filter(cve => {\n+            const cveDate = new Date(cve.alert_detected_at);\n             return cveDate >= initialDate && cveDate <= finalDate;\n         });\n \n-        const groupedCVEs = filteredCVEs.reduce((acc, cve) => {\n-            const agent = agents.find(agent => agent.public_agent_name === cve.agent_name);\n+        const groupedCVEs = filteredAlerts.reduce((acc, alert) => {\n+            const agent = agents.find(agent => agent.id === alert.agent_id);\n             if (!acc[agent.public_agent_name]) {\n                 acc[agent.public_agent_name] = { public_agent_name: agent.public_agent_name, agent_id: agent.id, eventCount: 0, events: [] };\n             }\n             acc[agent.public_agent_name].eventCount++;\n-            acc[agent.public_agent_name].events.push({ id: cve.vulnerability_id, desciption: cve.vulnerability_description, name: cve.vulnerability_name, date: cve.vulnerability_detected_at, severity: cve.vulnerability_severity });\n+            acc[agent.public_agent_name].events.push({ id: alert.alert_id, desciption: alert.alert_description, date: alert.alert_detected_at, severity: alert.alert_severity, ruleLevel: alert.alert_ruleLevel });\n \n             return acc;\n         }, {});\n \n-        const groupedCVEsByWeek = filteredCVEs.reduce((acc, cve) => {\n-            const cveDate = new Date(cve.vulnerability_detected_at);\n+        const groupedCVEsByWeek = filteredAlerts.reduce((acc, alert) => {\n+            const cveDate = new Date(alert.alert_detected_at);\n             const day = cveDate.getDay();\n             const diff = cveDate.getDate() - day + (day === 0 ? -6 : 1);\n             const weekStart = new Date(cveDate.setDate(diff));\n@@ -359,8 +372,8 @@ export class ReportService {\n         }, {});\n \n \n-        const groupedCVEsByMonth = filteredCVEs.reduce((acc, cve) => {\n-            const cveDate = new Date(cve.vulnerability_detected_at);\n+        const groupedCVEsByMonth = filteredAlerts.reduce((acc, cve) => {\n+            const cveDate = new Date(cve.alert_detected_at);\n             const year = cveDate.getFullYear();\n             const month = cveDate.getMonth() + 1;\n             const key = `${year}-${String(month).padStart(2, '0')}`;\n@@ -372,15 +385,14 @@ export class ReportService {\n         }, {});\n \n         const severityPercentages = {};\n-        const totalCVEs = filteredCVEs.filter((cve) => cve.vulnerability_severity != '-').length;\n-        const severityCounts = filteredCVEs.reduce((acc, cve) => {\n-            if(cve.vulnerability_severity == '-') return acc;\n-            acc[cve.vulnerability_severity] = (acc[cve.vulnerability_severity] || 0) + 1;\n+        const totalAlerts = filteredAlerts.length;\n+        const severityCounts = filteredAlerts.reduce((acc, alert) => {\n+            acc[alert.alert_severity] = (acc[alert.alert_severity] || 0) + 1;\n             return acc;\n         }, {});\n-        \n+\n         for (const severity in severityCounts) {\n-            severityPercentages[severity] = ((severityCounts[severity] / totalCVEs) * 100).toFixed(2);\n+            severityPercentages[severity] = ((severityCounts[severity] / totalAlerts) * 100).toFixed(2);\n         }        \n \n         const output = {","src/wazuh/controllers/wazuh.controller.ts":"@@ -310,85 +310,6 @@ export class WazuhController {\n     }\n     \n \n-    @Get('minor-report')\n-    @InfrastructureAccess()\n-    @ApiOperation({\n-        summary: 'Devuelve los datos para el reporte leve',\n-    })\n-    @ApiQuery({\n-        name: 'initialDate',\n-        description: 'Fecha inicial del reporte',\n-        example: new Date(),\n-        required: true,\n-    })\n-    @ApiQuery({\n-        name: 'finalDate',\n-        description: 'Fecha final del reporte',\n-        example: new Date(),\n-        required: true,\n-    })\n-    @ApiResponse({\n-        status: 200,\n-        description: 'Datos para el reporte leve',\n-        type: Object,\n-    })\n-    @ApiQuery({\n-        name: 'infraIds',\n-        description: 'ID(s) de infraestructura a consultar',\n-        type: [Number],\n-        required: true,\n-        example: 1,\n-        isArray: true,\n-    })\n-    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n-    async getMinorReportData(\n-        @ActiveUser() user: UserActiveInterface,\n-        @UserInfrastructures() infraIds: number[],\n-        @Query('initialDate') initialDate: Date,\n-        @Query('finalDate') finalDate: Date\n-    ) {\n-        return await this.reportService.getDataForMinorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n-    }\n-\n-    @Get('mayor-report')\n-    @InfrastructureAccess()\n-    @ApiOperation({\n-        summary: 'Devuelve los datos para el reporte leve',\n-    })\n-    @ApiQuery({\n-        name: 'initialDate',\n-        description: 'Fecha inicial del reporte',\n-        example: new Date(),\n-        required: true,\n-    })\n-    @ApiQuery({\n-        name: 'finalDate',\n-        description: 'Fecha final del reporte',\n-        example: new Date(),\n-        required: true,\n-    })\n-    @ApiResponse({\n-        status: 200,\n-        description: 'Datos para el reporte leve',\n-        type: Object,\n-    })\n-    @ApiQuery({\n-        name: 'infraIds',\n-        description: 'ID(s) de infraestructura a consultar',\n-        type: [Number],\n-        required: true,\n-        example: 1,\n-        isArray: true,\n-    })\n-    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n-    async getMayorReportData(\n-        @ActiveUser() user: UserActiveInterface,\n-        @UserInfrastructures() infraIds: number[],\n-        @Query('initialDate') initialDate: Date,\n-        @Query('finalDate') finalDate: Date\n-    ) {\n-        return await this.reportService.getDataForMayorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n-    }\n \n     @UseInterceptors(WazuhConnectionInterceptor)\n     @Get('inventory/software/:agentid')"}