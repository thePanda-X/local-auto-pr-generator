{"src/infrastructure/infrastructure.service.ts":"@@ -38,6 +38,10 @@ export class InfrastructureService\n         private readonly companyRepository: Repository<Company>,\n     ) { }\n \n+    getInfrastructureById(id: number) {\n+        return this.infrastructureRepository.findOne({where: {id} });\n+    }\n+\n     async findAllWithPagination(\n         page?: number,\n         limit?: number,\n@@ -792,4 +796,13 @@ export class InfrastructureService\n             },\n         });\n     }\n+\n+    async getAllAgentsByInfrastructure(infrastructureId: number): Promise<WazuAgent[]> {\n+        return await this.deviceRepository.find({\n+            where: {\n+                infrastructure: { id: infrastructureId }\n+            },\n+            relations: ['infrastructure']\n+        });\n+    }\n }","src/report/report.module.ts":"@@ -6,11 +6,12 @@ import FileModule from 'src/files/files.module';\n import { CompanyModule } from 'src/company/company.module';\n import { InfrastructureModule } from 'src/infrastructure/infrastructure.module';\n import { I18nModule } from 'nestjs-i18n/dist/i18n.module';\n+import { WazuhModule } from 'src/wazuh/wazuh.module';\n \n @Module({\n-    imports: [AuthModule,  forwardRef(() => FileModule), forwardRef(() => CompanyModule), InfrastructureModule, ],\n+    imports: [AuthModule,  forwardRef(() => FileModule), forwardRef(() => CompanyModule), InfrastructureModule, forwardRef(() => WazuhModule)],\n     controllers: [ReportController],\n     providers: [ReportService],\n-    exports: []\n+    exports: [ReportService]\n })\n export class ReportModule {}","src/report/report.service.ts":"@@ -17,6 +17,9 @@ import { FileService } from 'src/files/services/files.service';\n import { ReportTypes } from './enums/report-types.enum';\n import { FileListInterface } from 'src/files/interfaces/file-list.interface';\n import { InfrastructureService } from 'src/infrastructure/infrastructure.service';\n+import { WazuAgent } from 'src/wazuh/entities/agent.entity';\n+import { IndexerService } from 'src/wazuh/services/indexer.service';\n+import { VulnerabilityInfoDTO } from 'src/wazuh/dto-outputs/vulnera-info.output.dto';\n \n @Injectable()\n export class ReportService {\n@@ -28,6 +31,7 @@ export class ReportService {\n         @Inject(forwardRef(() => CompanyService))\n         private readonly companyService: CompanyService,\n         private readonly i18n: I18nService,\n+        private readonly indexerService: IndexerService,\n     ) {}\n \n     /**\n@@ -193,4 +197,202 @@ export class ReportService {\n             }),\n         };\n     }\n+\n+\n+    async getDataForMinorReport(\n+        user: UserActiveInterface,\n+        infrastructureIds: number[],\n+        initialDate: Date,\n+        finalDate: Date = new Date()\n+    ) {\n+        const company = await this.companyService.getCompany(user, user.companyId);\n+    \n+        const infrastructureReports: Record<string, {\n+            agentsInfo: Record<string, {\n+                public_agent_name: string;\n+                agent_id: string;\n+                eventCount: number;\n+                events: {\n+                    desciption: string;\n+                    name: string;\n+                    date: string;\n+                }[];\n+            }>;\n+            eventsByWeek: Record<string, number>;\n+            eventsByMonth: Record<string, number>;\n+        }> = {};\n+    \n+        for (const infrastructureId of infrastructureIds) {\n+            const infrastructure = await this.infrastructureService.getInfrastructureById(infrastructureId);\n+            if (!infrastructure) {\n+                console.warn(`Infrastructure with ID ${infrastructureId} not found.`);\n+                continue;\n+            }\n+            const agents = await this.infrastructureService.getAllAgentsByInfrastructure(infrastructureId);\n+            const cvePromises = agents.map(agent => this.indexerService.getVulnerabilities(user, agent.id));\n+            const cves = await Promise.all(cvePromises);\n+            const cveArray: VulnerabilityInfoDTO[] = [].concat(...cves);\n+    \n+            const cveFormatted = cveArray.map(cve => ({\n+                agent_name: cve.agent_name,\n+                agent_id: cve.agent_build_original,\n+                vulnerability_detected_at: cve.vulnerability_detected_at,\n+                vulnerability_description: cve.vulnerability_description,\n+                vulnerability_name: cve.vulnerability_category\n+            }));\n+    \n+            const filteredCVEs = cveFormatted.filter(cve => {\n+                const cveDate = new Date(cve.vulnerability_detected_at);\n+                return cveDate >= initialDate && cveDate <= finalDate;\n+            });\n+    \n+            const groupedCVEsByAgent = filteredCVEs.reduce((acc, cve) => {\n+                const agent = agents.find(agent => agent.public_agent_name === cve.agent_name);\n+                if (!acc[agent.public_agent_name]) {\n+                    acc[agent.public_agent_name] = { public_agent_name: agent.public_agent_name, agent_id: agent.id, eventCount: 0, events: [] };\n+                }\n+                acc[agent.public_agent_name].eventCount++;\n+                acc[agent.public_agent_name].events.push({ desciption: cve.vulnerability_description, name: cve.vulnerability_name, date: cve.vulnerability_detected_at });\n+                return acc;\n+            }, {});\n+    \n+            const groupedCVEsByWeek = filteredCVEs.reduce((acc, cve) => {\n+                const cveDate = new Date(cve.vulnerability_detected_at);\n+                const day = cveDate.getDay();\n+                const diff = cveDate.getDate() - day + (day === 0 ? -6 : 1);\n+                const weekStart = new Date(cveDate.setDate(diff));\n+                const key = weekStart.toISOString().split('T')[0];\n+                if (!acc[key]) {\n+                    acc[key] = 0;\n+                }\n+                acc[key]++;\n+                return acc;\n+            }, {});\n+    \n+            const groupedCVEsByMonth = filteredCVEs.reduce((acc, cve) => {\n+                const cveDate = new Date(cve.vulnerability_detected_at);\n+                const year = cveDate.getFullYear();\n+                const month = cveDate.getMonth() + 1;\n+                const key = `${year}-${String(month).padStart(2, '0')}`;\n+                if (!acc[key]) {\n+                    acc[key] = 0;\n+                }\n+                acc[key]++;\n+                return acc;\n+            }, {});\n+    \n+            infrastructureReports[infrastructure.name] = {\n+                agentsInfo: groupedCVEsByAgent,\n+                eventsByWeek: groupedCVEsByWeek,\n+                eventsByMonth: groupedCVEsByMonth,\n+            };\n+        }\n+    \n+        const output = {\n+            companyName: company.name,\n+            infrastructureReports: infrastructureReports,\n+            startDate: initialDate,\n+            endDate: finalDate,\n+        };\n+    \n+        return output;\n+    }\n+\n+\n+    async getDataForMayorReport(\n+        user: UserActiveInterface,\n+        infrastructureIds: number[],\n+        initialDate: Date,\n+        finalDate: Date = new Date()\n+    ) {\n+        const company = await this.companyService.getCompany(user, user.companyId);\n+\n+        let agents: WazuAgent[] = [];\n+        const promises = infrastructureIds.map(id =>\n+            this.infrastructureService.getAllAgentsByInfrastructure(id)\n+        );\n+        const allInfraAgentsArrays = await Promise.all(promises);\n+        allInfraAgentsArrays.forEach(infraAgents => agents.push(...infraAgents));\n+\n+        const cvePromises = agents.map(agent => this.indexerService.getVulnerabilities(user, agent.id));\n+        const cves = await Promise.all(cvePromises);\n+        const cveArray: VulnerabilityInfoDTO[] = [].concat(...cves);\n+\n+        const cveFormatted = cveArray.map(cve => {\n+            return {\n+                agent_name: cve.agent_name,\n+                vulnerability_id: cve.vulnerability_id,\n+                vulnerability_detected_at: cve.vulnerability_detected_at,\n+                vulnerability_description: cve.vulnerability_description,\n+                vulnerability_name: cve.vulnerability_category,\n+                vulnerability_severity: cve.vulnerability_severity,\n+            }\n+        })\n+\n+        const filteredCVEs = cveFormatted.filter(cve => {\n+            const cveDate = new Date(cve.vulnerability_detected_at);\n+            return cveDate >= initialDate && cveDate <= finalDate;\n+        });\n+\n+        const groupedCVEs = filteredCVEs.reduce((acc, cve) => {\n+            const agent = agents.find(agent => agent.public_agent_name === cve.agent_name);\n+            if (!acc[agent.public_agent_name]) {\n+                acc[agent.public_agent_name] = { public_agent_name: agent.public_agent_name, agent_id: agent.id, eventCount: 0, events: [] };\n+            }\n+            acc[agent.public_agent_name].eventCount++;\n+            acc[agent.public_agent_name].events.push({ id: cve.vulnerability_id, desciption: cve.vulnerability_description, name: cve.vulnerability_name, date: cve.vulnerability_detected_at, severity: cve.vulnerability_severity });\n+\n+            return acc;\n+        }, {});\n+\n+        const groupedCVEsByWeek = filteredCVEs.reduce((acc, cve) => {\n+            const cveDate = new Date(cve.vulnerability_detected_at);\n+            const day = cveDate.getDay();\n+            const diff = cveDate.getDate() - day + (day === 0 ? -6 : 1);\n+            const weekStart = new Date(cveDate.setDate(diff));\n+            const key = weekStart.toISOString().split('T')[0];\n+            if (!acc[key]) {\n+                acc[key] = 0;\n+            }\n+            acc[key]++;\n+            return acc;\n+        }, {});\n+\n+\n+        const groupedCVEsByMonth = filteredCVEs.reduce((acc, cve) => {\n+            const cveDate = new Date(cve.vulnerability_detected_at);\n+            const year = cveDate.getFullYear();\n+            const month = cveDate.getMonth() + 1;\n+            const key = `${year}-${String(month).padStart(2, '0')}`;\n+            if (!acc[key]) {\n+                acc[key] = 0;\n+            }\n+            acc[key]++;\n+            return acc;\n+        }, {});\n+\n+        const severityPercentages = {};\n+        const totalCVEs = filteredCVEs.filter((cve) => cve.vulnerability_severity != '-').length;\n+        const severityCounts = filteredCVEs.reduce((acc, cve) => {\n+            if(cve.vulnerability_severity == '-') return acc;\n+            acc[cve.vulnerability_severity] = (acc[cve.vulnerability_severity] || 0) + 1;\n+            return acc;\n+        }, {});\n+        \n+        for (const severity in severityCounts) {\n+            severityPercentages[severity] = ((severityCounts[severity] / totalCVEs) * 100).toFixed(2);\n+        }        \n+\n+        const output = {\n+            companyName: company.name,\n+            agentsInfo: groupedCVEs,\n+            eventsByWeek: groupedCVEsByWeek,\n+            eventsByMonth: groupedCVEsByMonth,\n+            severityPercentages: severityPercentages,\n+            startDate: initialDate,\n+            endDate: finalDate,\n+        };\n+\n+        return output;\n+    }\n }","src/wazuh/controllers/wazuh.controller.ts":"@@ -2,7 +2,9 @@ import {\n     Body,\n     Controller,\n     Delete,\n+    forwardRef,\n     Get,\n+    Inject,\n     Param,\n     ParseIntPipe,\n     Post,\n@@ -40,6 +42,7 @@ import { IndexerService } from '../services/indexer.service';\n import { WazuhService } from '../services/wazuh.service';\n import { UserInfrastructures } from 'src/infrastructure/decorators/user-infrastructures.decorator';\n import { InfrastructureAccess } from 'src/infrastructure/decorators/infrastructure-access.decorator';\n+import { ReportService } from 'src/report/report.service';\n \n /**\n  * ### WazuhController\n@@ -59,6 +62,7 @@ export class WazuhController {\n     constructor(\n         private readonly wazuhService: WazuhService,\n         private readonly indexerService: IndexerService,\n+        private readonly reportService: ReportService,\n     ) {}\n \n     @UseInterceptors(WazuhConnectionInterceptor)\n@@ -273,6 +277,86 @@ export class WazuhController {\n         return await this.indexerService.getPaginatedVulnerabilities(user, id, page, pageSize);\n     }\n \n+    @Get('minor-report')\n+    @InfrastructureAccess()\n+    @ApiOperation({\n+        summary: 'Devuelve los datos para el reporte leve',\n+    })\n+    @ApiQuery({\n+        name: 'initialDate',\n+        description: 'Fecha inicial del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiQuery({\n+        name: 'finalDate',\n+        description: 'Fecha final del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiResponse({\n+        status: 200,\n+        description: 'Datos para el reporte leve',\n+        type: Object,\n+    })\n+    @ApiQuery({\n+        name: 'infraIds',\n+        description: 'ID(s) de infraestructura a consultar',\n+        type: [Number],\n+        required: true,\n+        example: 1,\n+        isArray: true,\n+    })\n+    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n+    async getMinorReportData(\n+        @ActiveUser() user: UserActiveInterface,\n+        @UserInfrastructures() infraIds: number[],\n+        @Query('initialDate') initialDate: Date,\n+        @Query('finalDate') finalDate: Date\n+    ) {\n+        return await this.reportService.getDataForMinorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n+    }\n+\n+    @Get('mayor-report')\n+    @InfrastructureAccess()\n+    @ApiOperation({\n+        summary: 'Devuelve los datos para el reporte leve',\n+    })\n+    @ApiQuery({\n+        name: 'initialDate',\n+        description: 'Fecha inicial del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiQuery({\n+        name: 'finalDate',\n+        description: 'Fecha final del reporte',\n+        example: new Date(),\n+        required: true,\n+    })\n+    @ApiResponse({\n+        status: 200,\n+        description: 'Datos para el reporte leve',\n+        type: Object,\n+    })\n+    @ApiQuery({\n+        name: 'infraIds',\n+        description: 'ID(s) de infraestructura a consultar',\n+        type: [Number],\n+        required: true,\n+        example: 1,\n+        isArray: true,\n+    })\n+    @Auth(Role.USER, Role.ADMIN) //@todo: quitar el enpoint de prueba cuando exista la autoamticacion de reports\n+    async getMayorReportData(\n+        @ActiveUser() user: UserActiveInterface,\n+        @UserInfrastructures() infraIds: number[],\n+        @Query('initialDate') initialDate: Date,\n+        @Query('finalDate') finalDate: Date\n+    ) {\n+        return await this.reportService.getDataForMayorReport(user, infraIds, new Date(initialDate), new Date(finalDate));\n+    }\n+\n     @UseInterceptors(WazuhConnectionInterceptor)\n     @Get('inventory/software/:agentid')\n     @ApiOperation({","src/wazuh/services/indexer.service.ts":"@@ -83,102 +83,106 @@ export class IndexerService extends ApiRequest {\n     public async getVulnerabilities(\n         user: UserActiveInterface,\n         id: number,\n-    ): Promise<VulnerabilityInfoDTO[]> {\n-        if (!(await this.wazuhService.checkAgentPermissions(user.id, id)))\n-            throw new ErrorManager({\n-                type: 'NOT_FOUND',\n-                message: this.i18n.t('error.WAZUH.NOT_FOUND', {\n-                    lang: user.language,\n-                }),\n-            });\n-\n+        initialDate?: Date,\n+        finalDate?: Date,\n+      ): Promise<VulnerabilityInfoDTO[]> {\n+        \n+        if (!(await this.wazuhService.checkAgentPermissions(user.id, id))) {\n+          throw new ErrorManager({\n+            type: 'NOT_FOUND',\n+            message: this.i18n.t('error.WAZUH.NOT_FOUND', {\n+              lang: user.language,\n+            }),\n+          });\n+        }\n+    \n         const agent = await this.wazuhBaseService.getAgentById(id);\n-\n-        const formattedId = agent.agent_id.toString().padStart(3, '0');\n-\n+        const formattedId = String(agent.agent_id).padStart(3, '0');\n+        const dateRange = {};\n+    \n+        if (initialDate) {\n+          dateRange['gte'] = initialDate.toISOString();\n+        }\n+        if (finalDate) {\n+          dateRange['lte'] = finalDate.toISOString();\n+        }\n+    \n+        const mustClauses: any[] = [\n+          { match: { 'agent.id': formattedId } },\n+          { exists: { field: 'vulnerability' } },\n+          ...(Object.keys(dateRange).length > 0\n+            ? [{ range: { 'vulnerability.published': dateRange } }]\n+            : []),\n+        ];\n+    \n         const query = {\n-            query: {\n-                bool: {\n-                    must: [\n-                        { match: { 'agent.id': formattedId } },\n-                        { exists: { field: 'vulnerability' } },\n-                    ],\n-                },\n+          size: 1000,\n+          query: {\n+            bool: {\n+              must: mustClauses,\n             },\n-            size: 1000,\n+          },\n         };\n-\n+    \n         const response = await this.post(\n-            '/wazuh-states-vulnerabilities-*/_search',\n-            query,\n-            100000,\n+          'wazuh-states-vulnerabilities-*/_search',\n+          query,\n+          100000,\n         );\n-\n-        const vulnerabilities: VulnerabilityInfoDTO[] =\n-            response.data.hits.hits.map((hit) => {\n-                const source = hit._source;\n-                return {\n-                    agent_name: agent.public_agent_name ?? '',\n-                    package_name: source.package?.name ?? '',\n-                    package_version: source.package?.version ?? '',\n-                    vulnerability_description:\n-                        source.vulnerability?.description ?? '',\n-                    vulnerability_severity:\n-                        source.vulnerability?.severity ?? '',\n-                    vulnerability_id: source.vulnerability?.id ?? '',\n-                    agent_build_original: source.agent?.build?.original ?? '',\n-                    agent_type: source.agent?.type ?? '',\n-                    agent_version: source.agent?.version ?? '',\n-                    host_os_full: source.host?.os?.full ?? '',\n-                    host_os_kernel: source.host?.os?.kernel ?? '',\n-                    host_os_name: source.host?.os?.name ?? '',\n-                    host_os_platform: source.host?.os?.platform ?? '',\n-                    host_os_type: source.host?.os?.type ?? '',\n-                    host_os_version: source.host?.os?.version ?? '',\n-                    package_architecture: source.package?.architecture ?? '',\n-                    package_build_version: source.package?.build_version ?? '',\n-                    package_checksum: source.package?.checksum ?? '',\n-                    package_description: source.package?.description ?? '',\n-                    package_install_scope: source.package?.install_scope ?? '',\n-                    package_installed: source.package?.installed ?? false,\n-                    package_license: source.package?.license ?? '',\n-                    package_path: source.package?.path ?? '',\n-                    package_reference: source.package?.reference ?? '',\n-                    package_size: source.package?.size ?? 0,\n-                    package_type: source.package?.type ?? '',\n-                    vulnerability_category:\n-                        source.vulnerability?.category ?? '',\n-                    vulnerability_classification:\n-                        source.vulnerability?.classification ?? '',\n-                    vulnerability_detected_at:\n-                        source.vulnerability?.detected_at ?? '',\n-                    vulnerability_enumeration:\n-                        source.vulnerability?.enumeration ?? '',\n-                    vulnerability_published_at:\n-                        source.vulnerability?.published_at ?? '',\n-                    vulnerability_reference:\n-                        source.vulnerability?.reference ?? '',\n-                    vulnerability_report_id:\n-                        source.vulnerability?.report_id ?? '',\n-                    vulnerability_scanner_source:\n-                        source.vulnerability?.scanner?.source ?? '',\n-                    vulnerability_scanner_vendor:\n-                        source.vulnerability?.scanner?.vendor ?? '',\n-                    vulnerability_score_base:\n-                        source.vulnerability?.score?.base ?? 0,\n-                    vulnerability_score_environmental:\n-                        source.vulnerability?.score?.environmental ?? 0,\n-                    vulnerability_score_temporal:\n-                        source.vulnerability?.score?.temporal ?? 0,\n-                    vulnerability_score_version:\n-                        source.vulnerability?.score?.version ?? '',\n-                    vulnerability_under_evaluation:\n-                        source.vulnerability?.under_evaluation ?? false,\n-                };\n-            });\n-\n-        return vulnerabilities;\n-    }\n+    \n+        return response.data?.hits?.hits?.map((hit) => {\n+          const source = hit._source;\n+          const { agent: agentData, package: packageData, vulnerability } = source;\n+          const { os: osData, build: buildData } = agentData || {};\n+          const { score: vulnerabilityScore, scanner: vulnerabilityScanner } =\n+            vulnerability || {};\n+    \n+          return {\n+            agent_name: agent.public_agent_name ?? '',\n+            package_name: packageData?.name ?? '',\n+            package_version: packageData?.version ?? '',\n+            vulnerability_description: vulnerability?.description ?? '',\n+            vulnerability_severity: vulnerability?.severity ?? '',\n+            vulnerability_id: vulnerability?.id ?? '',\n+            agent_build_original: buildData?.original ?? '',\n+            agent_type: agentData?.type ?? '',\n+            agent_version: agentData?.version ?? '',\n+            host_os_full: osData?.full ?? '',\n+            host_os_kernel: osData?.kernel ?? '',\n+            host_os_name: osData?.name ?? '',\n+            host_os_platform: osData?.platform ?? '',\n+            host_os_type: osData?.type ?? '',\n+            host_os_version: osData?.version ?? '',\n+            package_architecture: packageData?.architecture ?? '',\n+            package_build_version: packageData?.build_version ?? '',\n+            package_checksum: packageData?.checksum ?? '',\n+            package_description: packageData?.description ?? '',\n+            package_install_scope: packageData?.install_scope ?? '',\n+            package_installed: packageData?.installed ?? false,\n+            package_license: packageData?.license ?? '',\n+            package_path: packageData?.path ?? '',\n+            package_reference: packageData?.reference ?? '',\n+            package_size: packageData?.size ?? 0,\n+            package_type: packageData?.type ?? '',\n+            vulnerability_category: vulnerability?.category ?? '',\n+            vulnerability_classification: vulnerability?.classification ?? '',\n+            vulnerability_detected_at: vulnerability?.detected_at ?? '',\n+            vulnerability_enumeration: vulnerability?.enumeration ?? '',\n+            vulnerability_published_at: vulnerability?.published_at ?? '',\n+            vulnerability_reference: vulnerability?.reference ?? '',\n+            vulnerability_report_id: vulnerability?.report_id ?? '',\n+            vulnerability_scanner_source: vulnerabilityScanner?.source ?? '',\n+            vulnerability_scanner_vendor: vulnerabilityScanner?.vendor ?? '',\n+            vulnerability_score_base: vulnerabilityScore?.base ?? 0,\n+            vulnerability_score_environmental:\n+              vulnerabilityScore?.environmental ?? 0,\n+            vulnerability_score_temporal: vulnerabilityScore?.temporal ?? 0,\n+            vulnerability_score_version: vulnerabilityScore?.version ?? '',\n+            vulnerability_under_evaluation:\n+              vulnerability?.under_evaluation ?? false,\n+          };\n+        }) ?? [];\n+      }\n \n \n     public async getPaginatedVulnerabilities(","src/wazuh/wazuh.module.ts":"@@ -25,6 +25,7 @@ import { WazuhQueueProcessor } from './processors/wazuh-queue.processor';\n import { WazuhBaseService } from './services/wazuh-base.service';\n import { UserCompanyService } from 'src/user/services/user-company.service';\n import { MailModule } from 'src/mail/mail.module';\n+import { ReportModule } from 'src/report/report.module';\n \n /**\n  * ### WazuhModule\n@@ -43,6 +44,7 @@ import { MailModule } from 'src/mail/mail.module';\n @Module({\n     imports: [\n         TypeOrmModule.forFeature([WazuAgent, Infrastructure, User, Alert]),\n+        forwardRef(() => ReportModule),\n         ScheduleModule.forRoot(),\n         forwardRef(() => CompanyModule),\n         forwardRef(() => AuthModule),"}