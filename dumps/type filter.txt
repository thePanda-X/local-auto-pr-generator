{"src/playbooks/protocol.controller.ts":"@@ -62,33 +62,6 @@ export class PlayBookController {\n         return await this.protocolService.createPlaybook(user, info);\n     }\n \n-    @Get('all-playbooks')\n-    @ApiOperation({ summary: 'Obtener todos los playbooks' })\n-    @ApiResponse({\n-        status: 200,\n-        description: 'Lista de playbooks recuperada exitosamente',\n-        type: [PlaybookInfoOutputDTO],\n-    })\n-    @ApiQuery({\n-        name: 'nameFilter',\n-        description: 'Filtro de playbooks por nombre',\n-        required: false,\n-    })\n-    @ApiQuery({\n-        name: 'typeFilter',\n-        description: 'Filtro de playbooks por tipo (example, user, company)',\n-        required: false,\n-        enum: ['example', 'user', 'company'],\n-    })\n-    async listProtocols(\n-        @ActiveUser() user: UserActiveInterface,\n-        @Query('nameFilter') nameFilter?: string,\n-        @Query('typeFilter') typeFilter?: string,\n-    ) {\n-        return await this.protocolService.listPlaybooks(user, nameFilter, typeFilter);\n-    }\n-\n-\n     @Get('get-all-protocols')\n     @Auth(Role.USER, Role.ADMIN, Role.SUPER_ADMIN)\n     @ApiOperation({\n@@ -109,12 +82,14 @@ export class PlayBookController {\n         name: 'typeFilter',\n         description: 'Filtro de playbooks por tipo (example, user, company)',\n         required: false,\n-        enum: ['example', 'user', 'company'],\n+        enum: ProtocolTags,\n+        isArray: true,\n+        enumName: 'ProtocolTags',\n     })\n     async getAllProtocols(\n         @ActiveUser() user: UserActiveInterface,\n         @Query('nameFilter') nameFilter?: string,\n-        @Query('typeFilter') typeFilter?: string,\n+        @Query('typeFilter') typeFilter?: ProtocolTags[],\n     ) {\n         return await this.protocolService.getAllProtocols(\n             user,","src/playbooks/protocol.service.ts":"@@ -314,62 +314,78 @@ export class ProtocolService {\n         }\n     }\n \n-    public async listPlaybooks(user: UserActiveInterface, nameFilter?: string, typeFilter?: string) {\n+    public async listPlaybooks(\n+        user: UserActiveInterface,\n+        nameFilter?: string,\n+        typeFilters?: ProtocolTags[]\n+    ) {\n         try {\n-            let where: FindOptionsWhere<Protocols> = {};\n-\n-            if (nameFilter && nameFilter.length > 0) {\n-                where.name = ILike(`%${nameFilter.trim()}%`);\n-            }\n-            if (typeFilter) {\n-                if (typeFilter === 'example') {\n-                    where.isExample = true;\n-                } else if (typeFilter === 'user') {\n-                    where.company = null;\n-                } else if (typeFilter === 'company') {\n-                    where.company = { id: user.companyId };\n-                } else {\n-                    throw new ErrorManager({\n-                        type: 'BAD_REQUEST',\n-                        message: 'El filtro de tipo de playbook no es válido.',\n-                    });\n+            let baseFilter: FindOptionsWhere<Protocols> = {};\n+            if (nameFilter && nameFilter.trim().length > 0) {\n+                baseFilter.name = ILike(`%${nameFilter.trim()}%`);\n+            }\n+\n+\n+\n+            const typeConditions: FindOptionsWhere<Protocols>[] = [];\n+            if (typeFilters && typeFilters.length > 0) {\n+                //formatear los filtros si solo se envia 1\n+                typeFilters = Array.isArray(typeFilters) ? typeFilters : [typeFilters]\n+                for (const filter of typeFilters) {\n+                    if (filter === ProtocolTags.EXAMPLE) {\n+                        typeConditions.push({ isExample: true });\n+                    } else if (filter === ProtocolTags.USER) {\n+                        typeConditions.push({ company: null });\n+                    } else if (filter === ProtocolTags.COMPANY) {\n+                        typeConditions.push({ company: { id: user.companyId } });\n+                    } else {\n+                        throw new ErrorManager({\n+                            type: 'BAD_REQUEST',\n+                            message: `El filtro de tipo de playbook no es válido.`,\n+                        });\n+                    }\n                 }\n             }\n \n             let playbooks;\n \n+            // metodo auxiliar para juntar 2 condiciones where\n+            const mergeConditions = (\n+                base: FindOptionsWhere<Protocols>,\n+                extras: FindOptionsWhere<Protocols>[]\n+            ): FindOptionsWhere<Protocols>[] => {\n+                if (extras.length === 0) return [base];\n+                return extras.map((extra) => ({ ...base, ...extra }));\n+            };\n+\n             if (user.role === Role.USER) {\n+                const userBase = { user: { id: user.id }, ...baseFilter };\n+                const companyBase = { company: { id: user.companyId }, ...baseFilter };\n+                const whereOptions: FindOptionsWhere<Protocols>[] = [\n+                    ...mergeConditions(userBase, typeConditions),\n+                    ...mergeConditions(companyBase, typeConditions),\n+                ];\n+\n                 playbooks = await this.protocolRepository.find({\n-                    where: [\n-                        {\n-                            user: { id: user.id },\n-                            ...where,\n-                        },\n-                        {\n-                            company: { id: user.companyId },\n-                            ...where,\n-                        },\n-                    ],\n+                    where: whereOptions,\n                     relations: ['company', 'user'],\n                 });\n             } else if (user.role === Role.ADMIN) {\n+                const adminBase = { company: { id: user.companyId }, ...baseFilter };\n+                const whereOptions = mergeConditions(adminBase, typeConditions);\n                 playbooks = await this.protocolRepository.find({\n-                    where: {\n-                        company: { id: user.companyId },\n-                        ...where,\n-                    },\n+                    where: whereOptions,\n                     relations: ['company', 'user'],\n                 });\n             } else if (user.role === Role.SUPER_ADMIN) {\n+                const superAdminBase = { isExample: false, ...baseFilter };\n+                const whereOptions = mergeConditions(superAdminBase, typeConditions);\n                 playbooks = await this.protocolRepository.find({\n-                    where: {\n-                        isExample: false,\n-                        ...where,\n-                    },\n+                    where: whereOptions,\n                     relations: ['company', 'user'],\n                 });\n-\n                 const examplePlaybooks = await this.listExamplePlaybooks(nameFilter);\n+                console.log(examplePlaybooks)\n                 playbooks = [...playbooks, ...examplePlaybooks];\n             } else {\n                 throw new ErrorManager({\n@@ -378,28 +394,43 @@ export class ProtocolService {\n                 });\n             }\n \n-            return playbooks.map((playbook) => ({\n-                id: playbook.id,\n-                name: playbook.name,\n-                creator: playbook.user.name,\n-                description: playbook.description ?? '',\n-                file_name: playbook.file_name,\n-                createdAt: playbook.createdAt,\n-                company: playbook.company\n-                    ? {\n-                        id: playbook.company.id,\n-                        name: playbook.company.name,\n-                    }\n-                    : null,\n-                editable: (playbook.user.id === user.id)\n-            }));\n+            return playbooks.map((playbook) => {\n+                // mapear la salida de los playbooks de ejemplo.\n+                if ('creator' in playbook) {\n+                    return {\n+                        ...playbook,\n+                        company: playbook.company || null,\n+                        editable: false,\n+                        isExample: true,\n+                    };\n+                } else {\n+                    return {\n+                        id: playbook.id,\n+                        name: playbook.name,\n+                        creator: playbook.user ? playbook.user.name : 'Unknown',\n+                        description: playbook.description ?? '',\n+                        file_name: playbook.file_name,\n+                        createdAt: playbook.createdAt,\n+                        company: playbook.company\n+                            ? {\n+                                id: playbook.company.id,\n+                                name: playbook.company.name,\n+                            }\n+                            : null,\n+                        editable: playbook.user ? playbook.user.id === user.id : false,\n+                        isExample: playbook.isExample,\n+                    };\n+                }\n+            });\n         } catch (error) {\n+            console.error('Detailed error:', error);\n             throw new ErrorManager({\n                 type: 'INTERNAL_SERVER_ERROR',\n                 message: 'Unexpected error listing playbooks',\n             });\n         }\n     }\n+      \n \n \n \n@@ -761,64 +792,108 @@ export class ProtocolService {\n     async getAllProtocols(\n         user: UserActiveInterface,\n         nameFilter?: string,\n-        typeFilter?: string,\n+        typeFilter?: ProtocolTags | ProtocolTags[]\n     ): Promise<AllPlaybookOutputDTO[]> {\n-\n-        const where: FindOptionsWhere<Protocols> = {};\n-\n-        if (nameFilter && nameFilter.length > 0) {\n-            where.name = ILike(`%${nameFilter.trim()}%`);\n+        const types: ProtocolTags[] = typeFilter\n+            ? Array.isArray(typeFilter)\n+                ? typeFilter\n+                : [typeFilter]\n+            : [];\n+        \n+        const baseWhere: FindOptionsWhere<Protocols> = {};\n+        if (nameFilter && nameFilter.trim().length > 0) {\n+            baseWhere.name = ILike(`%${nameFilter.trim()}%`);\n         }\n \n-        if (typeFilter) {\n-            if (typeFilter === 'example') {\n-                where.isExample = true;\n-            } else if (typeFilter === 'user') {\n-                where.company = null;\n-            } else if (typeFilter === 'company') {\n-                where.company = { id: user.companyId };\n-            } else {\n-                throw new ErrorManager({\n-                    type: 'BAD_REQUEST',\n-                    message: 'El filtro de tipo de playbook no es válido.',\n-                });\n+        let playbooks: any[] = []; \n+\n+        const buildConditionForTypeFilter = (type: ProtocolTags, extra?: FindOptionsWhere<Protocols>): FindOptionsWhere<Protocols> => {\n+            const condition: FindOptionsWhere<Protocols> = { ...baseWhere, ...extra };\n+            switch (type) {\n+                case ProtocolTags.EXAMPLE:\n+                    return { ...condition, isExample: true };\n+                case ProtocolTags.USER:\n+                    return { ...condition, user: { id: user.id }, company: null };\n+                case ProtocolTags.COMPANY:\n+                    return { ...condition, company: { id: user.companyId } };\n+                default:\n+                    throw new ErrorManager({\n+                        type: 'BAD_REQUEST',\n+                        message: 'El filtro de tipo de playbook no es válido.'\n+                    });\n             }\n-        }\n-\n-        let playbooks;\n-\n+        };\n+\n+        \n+        const typeConditions = types.map((type) => buildConditionForTypeFilter(type));\n+        \n+        const defaultConditions: FindOptionsWhere<Protocols>[] = [\n+            { ...baseWhere, user: { id: user.id } },\n+            { ...baseWhere, company: { id: user.companyId } },\n+            { ...baseWhere, isExample: true },\n+        ];\n+        \n+        const conditions = types.length > 0 ? typeConditions : defaultConditions;\n+        \n         if (user.role === Role.USER || user.role === Role.ADMIN) {\n+            \n             playbooks = await this.protocolRepository.find({\n-                where: [\n-                    { user: { id: user.id }, ...where },\n-                    { company: { id: user.companyId }, ...where },\n-                    { isExample: true, ...where }\n-                ],\n+                where: conditions,\n                 relations: ['company', 'user'],\n             });\n         } else if (user.role === Role.SUPER_ADMIN) {\n-            playbooks = await this.protocolRepository.find({\n-                where: { isExample: false, ...where },\n-                relations: ['company', 'user'],\n-            });\n+            const nonExampleConditions = (types.length > 0\n+                ? types.filter(tag => tag !== ProtocolTags.EXAMPLE)\n+                : [ProtocolTags.USER, ProtocolTags.COMPANY]\n+            ).map(type =>\n+                \n+                buildConditionForTypeFilter(type, { isExample: false })\n+            );\n+\n+            let nonExamplePlaybooks: Protocols[] = [];\n+            if (nonExampleConditions.length > 0) {\n+                nonExamplePlaybooks = await this.protocolRepository.find({\n+                    where: nonExampleConditions,\n+                    relations: ['company', 'user'],\n+                });\n+            }\n \n-            const examplePlaybooks = await this.listExamplePlaybooks(nameFilter);\n-            playbooks = [...playbooks, ...examplePlaybooks];\n+            let examplePlaybooks: any[] = [];\n+            if (types.length === 0 || types.includes(ProtocolTags.EXAMPLE)) {\n+                examplePlaybooks = await this.listExamplePlaybooks(nameFilter);\n+            }\n+            \n+            playbooks = [...nonExamplePlaybooks, ...examplePlaybooks];\n         } else {\n             throw new ErrorManager({\n                 type: 'FORBIDDEN',\n                 message: 'No tienes permiso para acceder a los playbooks.',\n             });\n         }\n-\n-        const mappedPlaybooks = playbooks.map(playbook => {\n+        \n+        const mappedPlaybooks = playbooks.map((playbook: any) => {\n             let tag: ProtocolTags;\n-            if (playbook.isExample) {\n-                tag = ProtocolTags.EXAMPLE;\n-            } else if (playbook.company) {\n-                tag = ProtocolTags.COMPANY;\n+            let creatorName: string;\n+            let companyObj = null;\n+            \n+            if (playbook.hasOwnProperty('isExample')) {\n+                if (playbook.isExample) {\n+                    tag = ProtocolTags.EXAMPLE;\n+                } else if (playbook.company) {\n+                    tag = ProtocolTags.COMPANY;\n+                } else {\n+                    tag = ProtocolTags.USER;\n+                }\n+                creatorName = playbook.user ? playbook.user.name : '';\n+                if (playbook.company) {\n+                    companyObj = {\n+                        id: playbook.company.id,\n+                        name: playbook.company.name,\n+                    };\n+                }\n             } else {\n-                tag = ProtocolTags.USER;\n+                tag = ProtocolTags.EXAMPLE;\n+                creatorName = playbook.creator;\n             }\n \n             return {\n@@ -827,19 +902,15 @@ export class ProtocolService {\n                 description: playbook.description ?? '',\n                 file_name: playbook.file_name,\n                 createdAt: playbook.createdAt,\n-                creator: playbook.user.name,\n-                company: playbook.company\n-                    ? {\n-                        id: playbook.company.id,\n-                        name: playbook.company.name,\n-                    }\n-                    : null,\n+                creator: creatorName,\n+                company: companyObj,\n                 tag: tag,\n             } as AllPlaybookOutputDTO;\n         });\n \n         return mappedPlaybooks;\n     }\n-\n+      \n+      \n \n }","src/user/user.controller.ts":"@@ -138,7 +138,7 @@ export class UserController {\n         type: Number,\n         description: 'Company ID',\n     })\n-    @ApiQuery({ name: 'userType', required: false, enum: UserType })\n+    @ApiQuery({ name: 'userType', required: false, enum: UserType, isArray: true, enumName:'UserType' })\n     async findAll(\n         @ActiveUser() activeUser: UserActiveInterface,\n         @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,\n@@ -147,7 +147,7 @@ export class UserController {\n         @Query('nameFilter') nameFilter: string,\n         @Query('infrastructureFilter') infrastructureFilter: number,\n         @Query('companyFilter') companyFilter: number,\n-        @Query('userType') UserType: UserType,\n+        @Query('userType') UserType: UserType[],\n     ) {\n         return await this.usersService.findAll(\n             activeUser,","src/user/user.service.ts":"@@ -492,7 +492,7 @@ export class UserService {\n         nameFilter?: string,\n         infrastructureFilter?: number,\n         companyFilter?: number,\n-        userType?: UserType,\n+        userType?: UserType[],\n     ): Promise<AllUsersOutputDto> {\n         if (activeUser.role === Role.SUPER_ADMIN) {\n             return this.superAdminFindAll(\n@@ -520,20 +520,18 @@ export class UserService {\n         pageSize: number = 10,\n         nameFilter?: string,\n         infrastructureFilter?: number,\n-        userType?: UserType,\n+        userTypes: UserType[] = [UserType.ACTIVE, UserType.BLOCKED],\n     ): Promise<AllUsersOutputDto> {\n         const where: FindOptionsWhere<User> = {};\n         const companyId = activeuser.companyId;\n-\n+    \n         if (nameFilter?.length > 0) {\n             where.name = ILike(`%${nameFilter}%`);\n         }\n-\n-        let users: any[] = [];\n+    \n         let total = 0;\n-\n         const findUsers = async (\n-            blockedStatus: boolean | null,\n+            blockedStatus: boolean,\n         ): Promise<[any[], number]> => {\n             const [result, count] = await this.userRepository.findAndCount({\n                 select: [\n@@ -550,16 +548,14 @@ export class UserService {\n                     ...where,\n                     userCompanies: {\n                         company: { id: companyId },\n-                        blocked:\n-                            blockedStatus !== null ? blockedStatus : undefined,\n-                        ...(userType !== UserType.DELETED &&\n-                        infrastructureFilter\n+                        blocked: blockedStatus,\n+                        ...(infrastructureFilter\n                             ? { infrastructure: { id: infrastructureFilter } }\n                             : {}),\n                     },\n                 },\n-                skip: (page - 1) * pageSize,\n-                take: pageSize,\n+                skip: 0,\n+                take: 0,\n                 order: { createdAt: 'DESC' },\n                 relations: [\n                     'infrastructure',\n@@ -569,41 +565,14 @@ export class UserService {\n             });\n             return [result, count];\n         };\n-\n-        if (userType) {\n-            let result: any[];\n-            let count: number;\n-\n-            switch (userType) {\n-                case UserType.ACTIVE:\n-                    [result, count] = await findUsers(false);\n-                    break;\n-                case UserType.BLOCKED:\n-                    [result, count] = await findUsers(true);\n-                    break;\n-                default:\n-                    return { content: [], total: 0, page, pageSize };\n-            }\n-\n-            total = count;\n-            users = result.map((user) => {\n-                const userCompany = user.userCompanies?.find(\n-                    (uc) => uc.companyId === companyId,\n-                );\n-                return this.mapUserToDto(\n-                    user,\n-                    userCompany?.blocked || false,\n-                    userType,\n-                );\n-            });\n-        } else {\n-            const [activeResult, activeCount] = await findUsers(false);\n-            const [blockedResult, blockedCount] = await findUsers(true);\n-\n-            total = activeCount + blockedCount;\n-\n-            const combined = [\n-                ...activeResult.map((user) => {\n+    \n+        const combined: any[] = [];\n+    \n+        if (userTypes.includes(UserType.ACTIVE)) {\n+            const [result, count] = await findUsers(false);\n+            total += count;\n+            combined.push(\n+                ...result.map((user) => {\n                     const userCompany = user.userCompanies?.find(\n                         (uc) => uc.companyId === companyId,\n                     );\n@@ -612,8 +581,15 @@ export class UserService {\n                         userCompany?.blocked || false,\n                         UserType.ACTIVE,\n                     );\n-                }),\n-                ...blockedResult.map((user) => {\n+                })\n+            );\n+        }\n+    \n+        if (userTypes.includes(UserType.BLOCKED)) {\n+            const [result, count] = await findUsers(true);\n+            total += count;\n+            combined.push(\n+                ...result.map((user) => {\n                     const userCompany = user.userCompanies?.find(\n                         (uc) => uc.companyId === companyId,\n                     );\n@@ -622,14 +598,14 @@ export class UserService {\n                         userCompany?.blocked || false,\n                         UserType.BLOCKED,\n                     );\n-                }),\n-            ].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n-\n-            const startIndex = (page - 1) * pageSize;\n-            users = combined.slice(startIndex, startIndex + pageSize);\n+                })\n+            );\n         }\n-\n-        return { content: users, total, page, pageSize };\n+    \n+        const sortedUsers = combined.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n+        const paginatedUsers = sortedUsers.slice((page - 1) * pageSize, page * pageSize);\n+    \n+        return { content: paginatedUsers, total, page, pageSize };\n     }\n \n     async superAdminFindAll(\n@@ -638,15 +614,15 @@ export class UserService {\n         nameFilter?: string,\n         infrastructureFilter?: number,\n         companyFilter?: number,\n-        userType?: UserType,\n+        userTypes: UserType[] = [UserType.ACTIVE, UserType.BLOCKED],\n     ): Promise<AllUsersOutputDto> {\n         const where: FindOptionsWhere<User> = {};\n-\n+    \n         if (nameFilter?.length > 0) {\n             where.name = ILike(`%${nameFilter}%`);\n         }\n-\n-        if (userType !== UserType.DELETED) {\n+    \n+        if (!userTypes.includes(UserType.DELETED)) {\n             if (infrastructureFilter) {\n                 where.userCompanies = {\n                     infrastructure: { id: infrastructureFilter },\n@@ -656,11 +632,9 @@ export class UserService {\n                 where.company = { id: companyFilter };\n             }\n         }\n-\n-        let users: any[] = [];\n+    \n         let total = 0;\n-\n-        const findOptions: FindManyOptions<User> = {\n+        const findOptionsBase: FindManyOptions<User> = {\n             select: [\n                 'id',\n                 'name',\n@@ -672,86 +646,56 @@ export class UserService {\n                 'isFirstLogin',\n                 'company'\n             ] as (keyof User)[],\n-            where,\n-            skip: (page - 1) * pageSize,\n-            take: pageSize,\n+            skip: 0,\n+            take: 0,\n             order: { createdAt: 'DESC' },\n             relations: ['infrastructure', 'company', 'userCompanies.company'],\n         };\n-\n-        if (userType === UserType.ACTIVE) {\n-            findOptions.where = { ...where, blocked: false };\n-            const [result, count] =\n-                await this.userRepository.findAndCount(findOptions);\n-            total = count;\n-            users = result.map((user) =>\n-                this.mapUserToDto(user, false, UserType.ACTIVE),\n-            );\n-        } else if (userType === UserType.BLOCKED) {\n-            findOptions.where = { ...where, blocked: true };\n-            const [result, count] =\n-                await this.userRepository.findAndCount(findOptions);\n-            total = count;\n-            users = result.map((user) =>\n-                this.mapUserToDto(user, false, UserType.BLOCKED),\n-            );\n-        } else if (userType === UserType.DELETED) {\n-            const deletedFindOptions: FindManyOptions<DeletedUser> = {\n-                select: ['id', 'name', 'mail', 'createdAt'],\n-                skip: (page - 1) * pageSize,\n-                take: pageSize,\n-                order: { createdAt: 'DESC' },\n-            };\n-            const [result, count] =\n-                await this.deletedUserRepository.findAndCount(\n-                    deletedFindOptions,\n-                );\n-            total = count;\n-            users = result.map((user) =>\n-                this.mapUserToDto(user, true, UserType.DELETED),\n-            );\n-        } else {\n-            const activeFindOptions: FindManyOptions<User> = {\n-                ...findOptions,\n+    \n+        const resultUsers: any[] = [];\n+    \n+        if (userTypes.includes(UserType.ACTIVE)) {\n+            const findOptions: FindManyOptions<User> = {\n+                ...findOptionsBase,\n                 where: { ...where, blocked: false },\n             };\n-            const blockedFindOptions: FindManyOptions<User> = {\n-                ...findOptions,\n+            const [result, count] = await this.userRepository.findAndCount(findOptions);\n+            total += count;\n+            resultUsers.push(\n+                ...result.map((u) => this.mapUserToDto(u, false, UserType.ACTIVE))\n+            );\n+        }\n+    \n+        if (userTypes.includes(UserType.BLOCKED)) {\n+            const findOptions: FindManyOptions<User> = {\n+                ...findOptionsBase,\n                 where: { ...where, blocked: true },\n             };\n+            const [result, count] = await this.userRepository.findAndCount(findOptions);\n+            total += count;\n+            resultUsers.push(\n+                ...result.map((u) => this.mapUserToDto(u, false, UserType.BLOCKED))\n+            );\n+        }\n+    \n+        if (userTypes.includes(UserType.DELETED)) {\n             const deletedFindOptions: FindManyOptions<DeletedUser> = {\n                 select: ['id', 'name', 'mail', 'createdAt'],\n+                order: { createdAt: 'DESC' },\n             };\n-\n-            const [activeResult, activeCount] =\n-                await this.userRepository.findAndCount(activeFindOptions);\n-            const [blockedResult, blockedCount] =\n-                await this.userRepository.findAndCount(blockedFindOptions);\n-            const [deletedResult, deletedCount] =\n-                await this.deletedUserRepository.findAndCount(\n-                    deletedFindOptions,\n-                );\n-\n-            total = activeCount + blockedCount + deletedCount;\n-\n-            const combined = [\n-                ...activeResult.map((u) =>\n-                    this.mapUserToDto(u, false, UserType.ACTIVE),\n-                ),\n-                ...blockedResult.map((u) =>\n-                    this.mapUserToDto(u, false, UserType.BLOCKED),\n-                ),\n-                ...deletedResult.map((u) =>\n-                    this.mapUserToDto(u, true, UserType.DELETED),\n-                ),\n-            ].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n-\n-            const startIndex = (page - 1) * pageSize;\n-            users = combined.slice(startIndex, startIndex + pageSize);\n+            const [result, count] = await this.deletedUserRepository.findAndCount(deletedFindOptions);\n+            total += count;\n+            resultUsers.push(\n+                ...result.map((u) => this.mapUserToDto(u, true, UserType.DELETED))\n+            );\n         }\n-\n-        return { content: users, total, page, pageSize };\n+    \n+        const sortedUsers = resultUsers.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n+        const paginatedUsers = sortedUsers.slice((page - 1) * pageSize, page * pageSize);\n+    \n+        return { content: paginatedUsers, total, page, pageSize };\n     }\n+    \n     async findAllByUserCompany(\n         activeUser: UserActiveInterface,\n         page: number = 1,"}